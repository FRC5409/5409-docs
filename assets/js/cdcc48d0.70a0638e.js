"use strict";(self.webpackChunk_5409=self.webpackChunk_5409||[]).push([[832],{4167:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Robots/Cobra/Project","title":"Project Development","description":"Drive","source":"@site/docs/Robots/Cobra/ProjectDevelopment.md","sourceDirName":"Robots/Cobra","slug":"/Robots/Cobra/Project","permalink":"/5409-docs/docs/Robots/Cobra/Project","draft":false,"unlisted":false,"editUrl":"https://github.com/frc5409/5409-docs/tree/main/docs/Robots/Cobra/ProjectDevelopment.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"Project","title":"Project Development","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/5409-docs/docs/Robots/Cobra/Overview"},"next":{"title":"Overview","permalink":"/5409-docs/docs/Robots/Stormont/Overview"}}');var n=o(4848),i=o(8453);const r={id:"Project",title:"Project Development",sidebar_position:2},s=void 0,l={},d=[{value:"Drive",id:"drive",level:2},{value:"Vision",id:"vision",level:2},{value:"Autonomous",id:"autonomous",level:2},{value:"Auto Align",id:"auto-align",level:2},{value:"Teleoperated",id:"teleoperated",level:2},{value:"Coral",id:"coral",level:3},{value:"Algae",id:"algae",level:3},{value:"Learning Insights",id:"learning-insights",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"drive",children:"Drive"}),"\n",(0,n.jsxs)(t.p,{children:["This year with the addition of AdvantageKit, we decided it was much easier to use ",(0,n.jsx)(t.a,{href:"https://docs.advantagekit.org/getting-started/template-projects/talonfx-swerve-template/",children:"AdvantageKit's TalonFX Swerve Template"}),". Made by ",(0,n.jsx)(t.a,{href:"https://www.thebluealliance.com/team/6328",children:"Team 6328"}),", it is a powerful resource for fast and effective swerve drive control. We then did some modifications to include Torque control on the motors to get an increase in peak power from FOC. From there we set up and tweaked the simulation for the template to include ",(0,n.jsx)(t.a,{href:"https://shenzhen-robotics-alliance.github.io/maple-sim/",children:"MapleSim"}),". This is optional but we find that it can lead to increased accuracy in simulation and offers more areas to find bugs before going on the real robot."]}),"\n",(0,n.jsx)(t.h2,{id:"vision",children:"Vision"}),"\n",(0,n.jsxs)(t.p,{children:["One of our takeaways from last year was having as ",(0,n.jsx)(t.strong,{children:"few cameras as possible"})," would make programming a lot easier. Having one camera doing your robot's ",(0,n.jsx)(t.strong,{children:"main function"})," was our approach. We also wanted the easiest and most effective solution, which is why we decided to use a ",(0,n.jsx)(t.a,{href:"https://docs.limelightvision.io/docs/docs-limelight/getting-started/summary",children:"Limelight"}),". In our case, we knew we wanted to have one camera that could see the tag when aligned to both the left and right branch so we would be confident when scoring. To do this we used ",(0,n.jsx)(t.a,{href:"https://docs.advantagescope.org/",children:"AdvantageScope"}),' to visualize a camera through a 3D field. We would run some basic autos and some "',(0,n.jsx)(t.em,{children:"teleop cycles"}),'".']}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"Used MT1 for rotation when close to an AprilTag; MT2 used when farther away to increase accuracy."})}),"\n",(0,n.jsx)(t.h2,{id:"autonomous",children:"Autonomous"}),"\n",(0,n.jsxs)(t.p,{children:["One of our big takeaways from last year was that our auto didn't score many points. Our design this year reflected that by maximizing auto points. We started designing our autos using ",(0,n.jsx)(t.a,{href:"https://pathplanner.dev",children:"PathPlanner"})," and our alignment commands would have to be custom. This is due to ",(0,n.jsx)(t.strong,{children:"PathPlanner ending paths early"})," with a timeout instead of an end condition - any wheel slippage or inaccuracy would cause the path to end before the robot has reached the target. Another improvement we used this year was implementing ",(0,n.jsx)(t.a,{href:"https://docs.wpilib.org/en/stable/docs/software/advanced-controls/system-identification/introduction.html",children:"SysID"})," which could tune some of our PID constants for the drive base. To increase accuracy we also made sure our ",(0,n.jsx)(t.em,{children:"robot config"})," was as accurate as possible: robot weight ",(0,n.jsx)(t.strong,{children:"in full"})," (bumpers, battery), moment of inertia, etc. One trick we used to get around paths ending early was to drive at a constant slow speed into the coral station when picking up - simple and effective."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsx)(t.p,{children:"Logging how long auto takes can aid with autonomous development"})}),"\n",(0,n.jsx)(t.h2,{id:"auto-align",children:"Auto Align"}),"\n",(0,n.jsxs)(t.p,{children:["At the start of the year, we knew right away it was going to be essential to have auto align to score on every branch quickly. The easiest and recommended way would be ",(0,n.jsx)(t.strong,{children:"triple PID"}),": x position, y position, and rotation. It works by taking your current pose and a target pose, then applies a ",(0,n.jsx)(t.strong,{children:"field-oriented"})," PID output for x, y, and rotation. This solution is fast with minimal setup. We used this method for our first competition and it worked great, but there was room to improve - it wouldn't always take the most optimal path to the point and we had issues with the robot traveling and then auto aligning."]}),"\n",(0,n.jsxs)(t.p,{children:["This is why we developed our custom auto align. It works similarly but with only two PID controllers: distance and rotation. We originally used a ",(0,n.jsx)(t.code,{children:"ProfiledPIDController"})," but soon realized there was a small yet painful bug - it wouldn't apply the constraints properly. So we created our custom Constrained PID Controller. To fix the second issue with traveling then auto align, we would reset the PID controller with our average wheel velocity. This would create a nice smooth transition when aligning with almost no possibility of human error."]}),"\n",(0,n.jsx)(t.h2,{id:"teleoperated",children:"Teleoperated"}),"\n",(0,n.jsxs)(t.p,{children:["Our goal for this year was ",(0,n.jsx)(t.strong,{children:"reducing as much load on the driver"})," as possible, meaning as ",(0,n.jsx)(t.strong,{children:"few buttons"})," as possible with minimal thinking for all the buttons. We managed to mainly have only 3: auto align left, auto align right, and remove algae."]}),"\n",(0,n.jsx)(t.h3,{id:"coral",children:"Coral"}),"\n",(0,n.jsxs)(t.p,{children:["We first started with loads of manual buttons: score, retract elevator, pickup, etc. We then soon noticed that we could have the robot intaking constantly if the robot didn't have a game piece. We also had human error with retracting the elevator close to the reef. Our idea was to have a ",(0,n.jsx)(t.em,{children:"danger zone"})," around the reef and have the elevator automatically retract after leaving the ",(0,n.jsx)(t.em,{children:"danger zone"}),". All the driver had to do to score was press a button - the robot would take over and do the rest of the work."]}),"\n",(0,n.jsx)(t.h3,{id:"algae",children:"Algae"}),"\n",(0,n.jsxs)(t.p,{children:["Algae removal was also fully automatic. There were three different types: perfect conditions, too close & L4, and too close. Perfect would be aligning while raising the elevator to the correct algae height based on the closest algae, grabbing the algae, then backing up. Too close L4 was when we just scored an L4 branch and we were in that ",(0,n.jsx)(t.em,{children:"danger zone"})," - the robot would keep the elevator up, travel to the middle of the branches, then go down into the algae and backup. Too close would be when the robot is too close to the reef (inside the ",(0,n.jsx)(t.em,{children:"danger zone"}),") - it would first backup, then do the perfect conditions command."]}),"\n",(0,n.jsx)(t.h2,{id:"learning-insights",children:"Learning Insights"}),"\n",(0,n.jsxs)(t.p,{children:["The biggest takeaway from this year was PathPlanner's issues - we wanted a faster and more efficient travel method. ",(0,n.jsx)(t.strong,{children:"Point-to-Point"})," is the next best option. ",(0,n.jsx)(t.a,{href:"https://choreo.autos/",children:"Choreo"})," does this, so we would be looking into that. Otherwise, we might create a custom Point-to-Point program or stick with PathPlanner. Always having some sort of filtering for your vision cameras is a must."]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>s});var a=o(6540);const n={},i=a.createContext(n);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);